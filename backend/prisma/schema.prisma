generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       Int                        @id @default(autoincrement())
  email                    String                     @unique
  password                 String
  firstName                String
  lastName                 String
  middleName               String?
  title                    String?
  role                     UserRole
  status                   UserStatus                 @default(PENDING_VERIFICATION)
  lastLogin                DateTime?
  emailVerified            Boolean                    @default(false)
  twoFactorEnabled         Boolean                    @default(false)
  phone                    String?
  dateOfBirth              DateTime?
  gender                   String?
  nationality              String?
  address                  String?
  createdAt                DateTime                   @default(now())
  updatedAt                DateTime                   @updatedAt
  institutionId            Int?
  facultyId                Int?
  departmentId             Int?
  calendarImports          AcademicCalendarImport[]
  academicPeriodsCreated   AcademicPeriod[]
  roleProfiles             RoleProfile[]
  batchScriptsAssigned     BatchScript[]              @relation("BatchScriptsAssigned")
  batchScriptsSealed       BatchScript[]              @relation("BatchScriptsSealed")
  courseLecturers          CourseLecturer[]
  courseOfferings          CourseOffering[]
  registrationsAdvised     CourseRegistration[]       @relation("RegistrationAdvisors")
  registrationsApproved    CourseRegistration[]       @relation("RegistrationApprovers")
  courseRegistrations      CourseRegistration[]       @relation("StudentRegistrations")
  departmentsAsHOD         Department[]               @relation("DepartmentHOD")
  courseEnrollments        CourseEnrollment[]         @relation("StudentEnrollments")
  enrollmentsAdvised       CourseEnrollment[]         @relation("EnrollmentAdvisors")
  enrollmentsApproved      CourseEnrollment[]         @relation("EnrollmentApprovers")
  attendanceMarked         ExamRegistration[]         @relation("AttendanceMarkers")
  examRegistrations        ExamRegistration[]         @relation("StudentExamRegistrations")
  scriptsSubmittedTo       ExamRegistration[]         @relation("ScriptSubmittedTo")
  timetablesApproved       ExamTimetable[]            @relation("TimetableApprover")
  timetablesCreated        ExamTimetable[]            @relation("TimetableCreator")
  timetablesPublished      ExamTimetable[]            @relation("TimetablePublisher")
  facultiesAsDean          Faculty[]                  @relation("FacultyDean")
  incidentsAssigned        Incident[]                 @relation("AssignedTo")
  incidentsReported        Incident[]                 @relation("ReportedBy")
  lecturerDepartments      LecturerDepartment[]
  movementsTo              ScriptMovement[]           @relation("MovementTo")
  scriptsHolding           Script[]                   @relation("ScriptsHolding")
  scriptsGraded            Script[]                   @relation("ScriptsGraded")
  academicHistory          StudentAcademicHistory?    @relation("StudentAcademicHistory")
  assessmentsGraded        StudentAssessment[]        @relation("GradedBy")
  studentAssessments       StudentAssessment[]
  semesterRecords          StudentSemesterRecord[]    @relation("StudentSemesterRecords")
  conflictsResolved        TimetableConflict[]
  timetableImports         TimetableImport[]
  department               Department?                @relation(fields: [departmentId], references: [id])
  faculty                  Faculty?                   @relation(fields: [facultyId], references: [id])
  institution              Institution?               @relation(fields: [institutionId], references: [id])
  // Logistics relations
  sessionLogsPerformed     ExamSessionLog[]
  sessionLogsAsStudent     ExamSessionLog[]           @relation("SessionLogStudent")
  sessionLogsAsInvigilator ExamSessionLog[]           @relation("SessionLogInvigilator")
  invigilatorAssignments   InvigilatorAssignment[]
  assignmentsAssigned      InvigilatorAssignment[]    @relation("AssignmentAssignedBy")
  studentVerifications     StudentVerification[]
  verificationsPerformed   StudentVerification[]      @relation("VerificationVerifier")
  examIncidentsReported       ExamIncident[]             @relation("IncidentReporter")
  examIncidentsAssigned       ExamIncident[]             @relation("IncidentAssignee")
  examIncidentsResolved       ExamIncident[]             @relation("IncidentResolver")
  timetableInvigilators       ExamTimetableInvigilator[] @relation("TimetableInvigilators")
  incidentAffectedAsStudent   ExamIncidentStudent[]      @relation("IncidentAffectedStudents")
  incidentAffectedAsInvigilator ExamIncidentInvigilator[] @relation("IncidentAffectedInvigilators")
  incidentWitness             ExamIncidentWitness[]      @relation("IncidentWitnesses")

  @@index([institutionId, role])
  @@index([facultyId, role])
  @@index([email, status])
  @@index([role, status])
  @@index([departmentId, role])
  @@index([status, lastLogin])
  @@map("users")
}

// Unified profile model replacing all individual profile tables
model RoleProfile {
  id          Int      @id @default(autoincrement())
  userId      Int
  role        UserRole
  permissions Json // Unified permissions schema
  metadata    Json? // Role-specific data (staffId, indexNumber, academicRank, etc.)
  isActive    Boolean  @default(true)
  isPrimary   Boolean  @default(false) // For users with multiple roles
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, role])
  @@index([userId, role, isActive])
  @@index([role, isActive])
  @@map("role_profiles")
}

// Note: Student and Lecturer specific data now stored in RoleProfile.metadata as JSON
// For quick access to critical fields, keep separate indexes or materialized views

model Institution {
  id              Int                      @id @default(autoincrement())
  name            String
  code            String                   @unique
  type            String                   @default("UNIVERSITY")
  status          String                   @default("ACTIVE")
  establishedYear Int?
  address         String?
  city            String?
  state           String?
  country         String?
  contactEmail    String?
  contactPhone    String?
  website         String?
  description     String?
  logoUrl         String?
  createdAt       DateTime                 @default(now())
  updatedAt       DateTime                 @updatedAt
  calendarImports AcademicCalendarImport[]
  academicYears   AcademicYear[]
  examTimetables  ExamTimetable[]
  faculties       Faculty[]
  users           User[]
  venues          Venue[]
  studentIdConfig StudentIdConfig?

  @@map("institutions")
}

model StudentIdConfig {
  id              Int                    @id @default(autoincrement())
  institutionId   Int                    @unique
  format          StudentIdFormat // SEQUENTIAL, ACADEMIC_YEAR, CUSTOM
  prefix          String? // e.g., "0721" or "BT/ITS"
  useAcademicYear Boolean                @default(false) // Include academic year in ID
  academicYearPos StudentIdYearPosition? // PREFIX, MIDDLE, SUFFIX
  separator       String? // e.g., "/" for "BT/ITS/24/001"
  paddingLength   Int                    @default(6) // e.g., 6 for "000001"
  startNumber     Int                    @default(1) // Starting sequence number
  currentNumber   Int                    @default(1) // Current sequence (auto-increments)
  pattern         String? // Custom pattern: {PREFIX}/{YEAR}/{SEQ}
  example         String? // Example ID for preview
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt
  institution     Institution            @relation(fields: [institutionId], references: [id], onDelete: Cascade)

  @@map("student_id_configs")
}

model Faculty {
  id              Int             @id @default(autoincrement())
  name            String
  code            String
  description     String?
  establishedYear Int?
  institutionId   Int
  deanId          Int?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  departments     Department[]
  examTimetables  ExamTimetable[]
  exams           Exam[]
  dean            User?           @relation("FacultyDean", fields: [deanId], references: [id])
  institution     Institution     @relation(fields: [institutionId], references: [id])
  users           User[]

  @@unique([institutionId, code])
  @@map("faculties")
}

model Department {
  id                  Int                  @id @default(autoincrement())
  name                String
  code                String
  type                String               @default("department")
  description         String?
  officeLocation      String?
  contactInfo         String?
  facultyId           Int
  hodId               Int?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  courses             Course[]
  faculty             Faculty              @relation(fields: [facultyId], references: [id])
  hod                 User?                @relation("DepartmentHOD", fields: [hodId], references: [id])
  lecturerDepartments LecturerDepartment[]
  programs            Program[]
  users               User[]

  @@unique([facultyId, code])
  @@map("departments")
}

model Program {
  id                    Int                    @id @default(autoincrement())
  name                  String
  code                  String
  type                  ProgramType
  level                 ProgramLevel
  durationYears         Float
  creditHours           Int?
  description           String?
  admissionRequirements String?
  isActive              Boolean                @default(true)
  departmentId          Int
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  programCourses        ProgramCourse[]
  department            Department             @relation(fields: [departmentId], references: [id])
  examTimetablePrograms ExamTimetableProgram[]

  @@unique([departmentId, code])
  @@map("programs")
}

model ProgramPrefix {
  id          Int         @id @default(autoincrement())
  programType ProgramType @unique
  prefix      String
  description String?
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@map("program_prefixes")
}

model Course {
  id                Int                  @id @default(autoincrement())
  name              String
  code              String               @unique
  description       String?
  creditHours       Int                  @default(3)
  contactHours      Int?
  level             Int
  courseType        CourseType           @default(CORE)
  prerequisites     String?
  corequisites      String?
  learningOutcomes  String?
  syllabus          String?
  assessmentMethods String?
  recommendedBooks  String?
  departmentId      Int
  isActive          Boolean              @default(true)
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  batchScripts      BatchScript[]
  courseOfferings   CourseOffering[]
  department        Department           @relation(fields: [departmentId], references: [id])
  timetableEntries  ExamTimetableEntry[]
  exams             Exam[]
  programCourses    ProgramCourse[]

  @@map("courses")
}

model ProgramCourse {
  id                    Int      @id @default(autoincrement())
  programId             Int
  courseId              Int
  level                 Int
  semester              Int
  isRequired            Boolean  @default(true)
  createdAt             DateTime @default(now())
  isCore                Boolean  @default(true)
  offeredInSemester1    Boolean  @default(true)
  offeredInSemester2    Boolean  @default(false)
  prerequisiteCourseIds String?
  updatedAt             DateTime @updatedAt
  yearInProgram         Int      @default(1)
  course                Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  program               Program  @relation(fields: [programId], references: [id], onDelete: Cascade)

  @@unique([programId, courseId, level, semester])
  @@map("program_courses")
}

model AcademicYear {
  id             Int             @id @default(autoincrement())
  yearCode       String          @unique
  startDate      DateTime
  endDate        DateTime
  isCurrent      Boolean         @default(false)
  institutionId  Int
  createdAt      DateTime        @default(now())
  institution    Institution     @relation(fields: [institutionId], references: [id])
  examTimetables ExamTimetable[]
  semesters      Semester[]

  @@map("academic_years")
}

model Semester {
  id                  Int                     @id @default(autoincrement())
  academicYearId      Int
  semesterNumber      Int
  name                String
  startDate           DateTime
  endDate             DateTime
  isCurrent           Boolean                 @default(false)
  createdAt           DateTime                @default(now())
  academicPeriod      AcademicPeriod?
  courseOfferings     CourseOffering[]
  courseRegistrations CourseRegistration[]
  courseEnrollments   CourseEnrollment[]
  examTimetables      ExamTimetable[]
  academicYear        AcademicYear            @relation(fields: [academicYearId], references: [id], onDelete: Cascade)
  semesterRecords     StudentSemesterRecord[]

  @@unique([academicYearId, semesterNumber])
  @@map("semesters")
}

model AcademicPeriod {
  id                    Int             @id @default(autoincrement())
  semesterId            Int             @unique
  registrationStartDate DateTime
  registrationEndDate   DateTime
  addDropStartDate      DateTime?
  addDropEndDate        DateTime?
  lectureStartDate      DateTime
  lectureEndDate        DateTime
  examStartDate         DateTime
  examEndDate           DateTime
  resultsReleaseDate    DateTime?
  maxCreditsPerStudent  Int             @default(24)
  minCreditsPerStudent  Int             @default(12)
  lateRegistrationFee   Float?
  isActive              Boolean         @default(true)
  isRegistrationOpen    Boolean         @default(false)
  isAddDropOpen         Boolean         @default(false)
  notes                 String?
  createdBy             Int?
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  creator               User?           @relation(fields: [createdBy], references: [id])
  semester              Semester        @relation(fields: [semesterId], references: [id], onDelete: Cascade)
  examTimetables        ExamTimetable[]

  @@map("academic_periods")
}

model AcademicCalendarImport {
  id               Int                  @id @default(autoincrement())
  institutionId    Int
  fileName         String
  fileUrl          String?
  fileType         CalendarFileType
  fileSize         Int?
  status           CalendarImportStatus @default(PENDING)
  recordsTotal     Int                  @default(0)
  recordsImported  Int                  @default(0)
  recordsFailed    Int                  @default(0)
  errorLog         String?
  validationErrors String?
  importMapping    String?
  importOptions    String?
  importedBy       Int
  importedAt       DateTime             @default(now())
  completedAt      DateTime?
  importer         User                 @relation(fields: [importedBy], references: [id])
  institution      Institution          @relation(fields: [institutionId], references: [id])

  @@map("academic_calendar_imports")
}

model CourseOffering {
  id                Int                      @id @default(autoincrement())
  courseId          Int
  semesterId        Int
  primaryLecturerId Int?
  maxEnrollment     Int?
  currentEnrollment Int                      @default(0)
  classroom         String?
  schedule          String?
  status            String                   @default("active")
  createdAt         DateTime                 @default(now())
  updatedAt         DateTime                 @updatedAt
  assessments       Assessment[]
  courseLecturers   CourseLecturer[]
  course            Course                   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  primaryLecturer   User?                    @relation(fields: [primaryLecturerId], references: [id])
  semester          Semester                 @relation(fields: [semesterId], references: [id], onDelete: Cascade)
  enrollments       CourseEnrollment[]
  registeredItems   CourseRegistrationItem[]

  @@unique([courseId, semesterId])
  @@index([semesterId, status])
  @@index([courseId, status])
  @@index([primaryLecturerId])
  @@map("course_offerings")
}

model CourseLecturer {
  id               Int            @id @default(autoincrement())
  courseOfferingId Int
  lecturerId       Int
  role             String         @default("instructor")
  createdAt        DateTime       @default(now())
  courseOffering   CourseOffering @relation(fields: [courseOfferingId], references: [id], onDelete: Cascade)
  lecturer         User           @relation(fields: [lecturerId], references: [id], onDelete: Cascade)

  @@unique([courseOfferingId, lecturerId])
  @@map("course_lecturers")
}

model LecturerDepartment {
  id           Int        @id @default(autoincrement())
  lecturerId   Int
  departmentId Int
  isPrimary    Boolean    @default(false)
  role         String?
  createdAt    DateTime   @default(now())
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)
  lecturer     User       @relation(fields: [lecturerId], references: [id], onDelete: Cascade)

  @@unique([lecturerId, departmentId])
  @@map("lecturer_departments")
}

// Unified model replacing both Enrollment and CourseRegistration/CourseRegistrationItem
model CourseEnrollment {
  id               Int @id @default(autoincrement())
  studentId        Int
  courseOfferingId Int
  semesterId       Int

  // Registration tracking
  registeredAt DateTime               @default(now())
  status       EnrollmentStatus       @default(ACTIVE)
  itemStatus   RegistrationItemStatus @default(REGISTERED)

  // Approval workflow
  advisorId          Int?
  advisorApprovedAt  DateTime?
  approverId         Int?
  approverApprovedAt DateTime?

  // Academic tracking
  grade       String?
  gradePoints Float?
  attendance  Float?

  // Drop tracking
  droppedAt  DateTime?
  dropReason String?

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  student        User           @relation("StudentEnrollments", fields: [studentId], references: [id], onDelete: Cascade)
  courseOffering CourseOffering @relation(fields: [courseOfferingId], references: [id], onDelete: Cascade)
  semester       Semester       @relation(fields: [semesterId], references: [id], onDelete: Cascade)
  advisor        User?          @relation("EnrollmentAdvisors", fields: [advisorId], references: [id])
  approver       User?          @relation("EnrollmentApprovers", fields: [approverId], references: [id])

  @@unique([studentId, courseOfferingId])
  @@index([studentId, semesterId])
  @@index([semesterId, status])
  @@index([courseOfferingId, status])
  @@index([studentId, status])
  @@index([advisorId, status])
  @@map("course_enrollments")
}

model CourseRegistration {
  id           Int                      @id @default(autoincrement())
  studentId    Int
  semesterId   Int
  advisorId    Int?
  approverId   Int?
  status       RegistrationStatus       @default(ACTIVE)
  totalCredits Int                      @default(0)
  createdAt    DateTime                 @default(now())
  updatedAt    DateTime                 @updatedAt
  advisor      User?                    @relation("RegistrationAdvisors", fields: [advisorId], references: [id])
  approver     User?                    @relation("RegistrationApprovers", fields: [approverId], references: [id])
  student      User                     @relation("StudentRegistrations", fields: [studentId], references: [id], onDelete: Cascade)
  semester     Semester                 @relation(fields: [semesterId], references: [id], onDelete: Cascade)
  courses      CourseRegistrationItem[]

  @@unique([studentId, semesterId])
  @@index([studentId, status])
  @@index([semesterId, status])
  @@map("course_registrations")
}

model CourseRegistrationItem {
  id               Int                    @id @default(autoincrement())
  registrationId   Int
  courseOfferingId Int
  status           RegistrationItemStatus @default(REGISTERED)
  droppedAt        DateTime?
  dropReason       String?
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt
  registration     CourseRegistration     @relation(fields: [registrationId], references: [id], onDelete: Cascade)
  courseOffering   CourseOffering         @relation(fields: [courseOfferingId], references: [id], onDelete: Cascade)

  @@unique([registrationId, courseOfferingId])
  @@index([registrationId])
  @@index([courseOfferingId])
  @@map("course_registration_items")
}

model StudentSemesterRecord {
  id                 Int              @id @default(autoincrement())
  studentId          Int
  semesterId         Int
  coursesRegistered  Int              @default(0)
  coursesCompleted   Int              @default(0)
  coursesFailed      Int              @default(0)
  coursesDropped     Int              @default(0)
  coursesInProgress  Int              @default(0)
  creditsAttempted   Int              @default(0)
  creditsEarned      Int              @default(0)
  semesterGPA        Float?
  cumulativeGPA      Float?
  totalGradePoints   Float            @default(0)
  totalCreditsEarned Int              @default(0)
  academicStanding   AcademicStanding @default(GOOD_STANDING)
  isOnProbation      Boolean          @default(false)
  probationCount     Int              @default(0)
  remarksFromAdvisor String?
  isFinalized        Boolean          @default(false)
  finalizedAt        DateTime?
  finalizedBy        Int?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  semester           Semester         @relation(fields: [semesterId], references: [id], onDelete: Cascade)
  student            User             @relation("StudentSemesterRecords", fields: [studentId], references: [id], onDelete: Cascade)

  @@unique([studentId, semesterId])
  @@index([studentId])
  @@index([semesterId])
  @@map("student_semester_records")
}

model StudentAcademicHistory {
  id                      Int              @id @default(autoincrement())
  studentId               Int              @unique
  admissionYear           String
  admissionSemester       Int              @default(1)
  expectedGraduationYear  String?
  currentLevel            Int              @default(100)
  currentSemester         Int              @default(1)
  totalSemestersCompleted Int              @default(0)
  cumulativeGPA           Float?
  overallCreditsEarned    Int              @default(0)
  overallCreditsAttempted Int              @default(0)
  currentStatus           AcademicStanding @default(GOOD_STANDING)
  hasGraduated            Boolean          @default(false)
  graduationDate          DateTime?
  levelProgressionHistory String?
  probationHistory        String?
  awardsAndHonors         String?
  lastUpdated             DateTime         @updatedAt
  createdAt               DateTime         @default(now())
  student                 User             @relation("StudentAcademicHistory", fields: [studentId], references: [id], onDelete: Cascade)

  @@index([studentId])
  @@map("student_academic_history")
}

model AssessmentType {
  id            Int          @id @default(autoincrement())
  name          String       @unique
  description   String?
  defaultWeight Float?
  assessments   Assessment[]

  @@map("assessment_types")
}

model Assessment {
  id                 Int                 @id @default(autoincrement())
  courseOfferingId   Int
  assessmentTypeId   Int
  title              String
  description        String?
  totalMarks         Float
  weightPercentage   Float
  dueDate            DateTime?
  instructions       String?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  assessmentType     AssessmentType      @relation(fields: [assessmentTypeId], references: [id])
  courseOffering     CourseOffering      @relation(fields: [courseOfferingId], references: [id], onDelete: Cascade)
  studentAssessments StudentAssessment[]

  @@map("assessments")
}

model StudentAssessment {
  id           Int        @id @default(autoincrement())
  assessmentId Int
  studentId    Int
  score        Float?
  submittedAt  DateTime?
  gradedAt     DateTime?
  gradedById   Int?
  feedback     String?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  assessment   Assessment @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  gradedBy     User?      @relation("GradedBy", fields: [gradedById], references: [id])
  student      User       @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@unique([assessmentId, studentId])
  @@map("student_assessments")
}

model Exam {
  id                  Int                  @id @default(autoincrement())
  title               String
  courseId            Int
  facultyId           Int
  examDate            DateTime
  startTime           DateTime
  endTime             DateTime
  duration            Int
  venueId             Int?
  roomId              Int?
  status              ExamStatus           @default(PLANNED)
  instructions        String?
  specialRequirements String?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  createdBy           Int
  examSessions        ExamSession[]
  timetableEntries    ExamTimetableEntry[]
  course              Course               @relation(fields: [courseId], references: [id])
  faculty             Faculty              @relation(fields: [facultyId], references: [id])
  room                Room?                @relation(fields: [roomId], references: [id])
  venue               Venue?               @relation(fields: [venueId], references: [id])
  incidents           Incident[]
  scripts             Script[]

  @@index([examDate, status])
  @@index([courseId, examDate])
  @@index([facultyId, examDate])
  @@index([venueId, examDate])
  @@index([status, examDate])
  @@map("exams")
}

model ExamSession {
  id              Int       @id @default(autoincrement())
  examId          Int
  sessionDate     DateTime
  startTime       DateTime
  endTime         DateTime
  actualStartTime DateTime?
  actualEndTime   DateTime?
  notes           String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  exam            Exam      @relation(fields: [examId], references: [id])

  @@map("exam_sessions")
}

model ExamTimetable {
  id                   Int                     @id @default(autoincrement())
  title                String
  description          String?
  academicYearId       Int
  semesterId           Int
  academicPeriodId     Int?
  institutionId        Int
  facultyId            Int?
  startDate            DateTime
  endDate              DateTime
  status               ExamTimetableStatus     @default(DRAFT)
  isPublished          Boolean                 @default(false)
  publishedAt          DateTime?
  publishedBy          Int?
  approvalStatus       TimetableApprovalStatus @default(NOT_SUBMITTED)
  approvedBy           Int?
  approvedAt           DateTime?
  rejectionReason      String?
  allowOverlaps        Boolean                 @default(false)
  autoResolveConflicts Boolean                 @default(true)
  defaultExamDuration  Int                     @default(180)
  totalExams           Int                     @default(0)
  totalConflicts       Int                     @default(0)
  venuesUtilization    Float?
  createdBy            Int
  createdAt            DateTime                @default(now())
  updatedAt            DateTime                @updatedAt
  entries              ExamTimetableEntry[]
  academicPeriod       AcademicPeriod?         @relation(fields: [academicPeriodId], references: [id])
  academicYear         AcademicYear            @relation(fields: [academicYearId], references: [id], onDelete: Cascade)
  approver             User?                   @relation("TimetableApprover", fields: [approvedBy], references: [id])
  creator              User                    @relation("TimetableCreator", fields: [createdBy], references: [id])
  faculty              Faculty?                @relation(fields: [facultyId], references: [id])
  institution          Institution             @relation(fields: [institutionId], references: [id])
  publisher            User?                   @relation("TimetablePublisher", fields: [publishedBy], references: [id])
  semester             Semester                @relation(fields: [semesterId], references: [id], onDelete: Cascade)
  conflicts            TimetableConflict[]
  imports              TimetableImport[]

  @@index([institutionId, academicYearId, semesterId])
  @@index([status, isPublished])
  @@map("exam_timetables")
}

model ExamTimetableEntry {
  id                  Int                      @id @default(autoincrement())
  timetableId         Int
  examId              Int?
  courseId            Int
  level               Int?
  studentCount        Int?
  examDate            DateTime
  startTime           DateTime
  endTime             DateTime
  duration            Int
  venueId             Int
  seatingCapacity     Int?
  chiefInvigilatorId  Int?
  status              ExamTimetableEntryStatus @default(DRAFT)
  notes               String?
  specialRequirements String?
  hasConflicts        Boolean                  @default(false)
  conflictDetails     String?
  createdAt           DateTime                 @default(now())
  updatedAt           DateTime                 @updatedAt

  // Relations
  batchScripts      BatchScript[]
  examRegistrations ExamRegistration[]
  course            Course              @relation(fields: [courseId], references: [id])
  exam              Exam?               @relation(fields: [examId], references: [id])
  timetable         ExamTimetable       @relation(fields: [timetableId], references: [id], onDelete: Cascade)
  venue             Venue               @relation(fields: [venueId], references: [id])
  conflictsAsEntry1 TimetableConflict[] @relation("ConflictEntry1")
  conflictsAsEntry2 TimetableConflict[] @relation("ConflictEntry2")

  // Many-to-many relations via junction tables
  programs     ExamTimetableProgram[]
  rooms        ExamTimetableRoom[]
  invigilators ExamTimetableInvigilator[]

  // Logistics relations
  sessionLogs            ExamSessionLog[]
  invigilatorAssignments InvigilatorAssignment[]
  studentVerifications   StudentVerification[]
  examIncidents          ExamIncident[]
  examLogistics          ExamLogistics?

  @@index([timetableId, examDate])
  @@index([courseId])
  @@index([venueId, examDate, startTime])
  @@index([status, hasConflicts])
  @@map("exam_timetable_entries")
}

// Junction table for ExamTimetableEntry and Program many-to-many relationship
model ExamTimetableProgram {
  id               Int      @id @default(autoincrement())
  timetableEntryId Int
  programId        Int
  createdAt        DateTime @default(now())

  timetableEntry ExamTimetableEntry @relation(fields: [timetableEntryId], references: [id], onDelete: Cascade)
  program        Program            @relation(fields: [programId], references: [id], onDelete: Cascade)

  @@unique([timetableEntryId, programId])
  @@index([timetableEntryId])
  @@index([programId])
  @@map("exam_timetable_programs")
}

// Junction table for ExamTimetableEntry and Room many-to-many relationship
model ExamTimetableRoom {
  id               Int      @id @default(autoincrement())
  timetableEntryId Int
  roomId           Int
  capacity         Int? // Capacity allocated for this exam in this room
  createdAt        DateTime @default(now())

  timetableEntry ExamTimetableEntry @relation(fields: [timetableEntryId], references: [id], onDelete: Cascade)
  room           Room               @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@unique([timetableEntryId, roomId])
  @@index([timetableEntryId])
  @@index([roomId])
  @@map("exam_timetable_rooms")
}

// Junction table for ExamTimetableEntry and Invigilator assignment
model ExamTimetableInvigilator {
  id               Int             @id @default(autoincrement())
  timetableEntryId Int
  invigilatorId    Int
  role             InvigilatorRole @default(INVIGILATOR)
  assignedAt       DateTime        @default(now())

  timetableEntry ExamTimetableEntry @relation(fields: [timetableEntryId], references: [id], onDelete: Cascade)
  invigilator    User               @relation("TimetableInvigilators", fields: [invigilatorId], references: [id], onDelete: Cascade)

  @@unique([timetableEntryId, invigilatorId])
  @@index([timetableEntryId])
  @@index([invigilatorId])
  @@map("exam_timetable_invigilators")
}

model TimetableConflict {
  id                  String             @id @default(uuid())
  timetableId         Int
  type                ConflictType
  severity            ConflictSeverity   @default(MEDIUM)
  entry1Id            Int
  entry2Id            Int
  additionalEntryIds  String?
  description         String
  affectedStudents    Int?
  affectedPrograms    String?
  canAutoResolve      Boolean            @default(false)
  suggestedResolution String?
  isResolved          Boolean            @default(false)
  resolvedAt          DateTime?
  resolvedBy          Int?
  detectedAt          DateTime           @default(now())
  entry1              ExamTimetableEntry @relation("ConflictEntry1", fields: [entry1Id], references: [id], onDelete: Cascade)
  entry2              ExamTimetableEntry @relation("ConflictEntry2", fields: [entry2Id], references: [id], onDelete: Cascade)
  resolver            User?              @relation(fields: [resolvedBy], references: [id])
  timetable           ExamTimetable      @relation(fields: [timetableId], references: [id], onDelete: Cascade)

  @@index([timetableId, isResolved])
  @@index([type, severity])
  @@map("timetable_conflicts")
}

model TimetableImport {
  id               Int                   @id @default(autoincrement())
  timetableId      Int?
  fileName         String
  fileUrl          String?
  fileType         TimetableFileType
  fileSize         Int?
  status           TimetableImportStatus @default(PENDING)
  totalRecords     Int                   @default(0)
  importedRecords  Int                   @default(0)
  failedRecords    Int                   @default(0)
  skippedRecords   Int                   @default(0)
  errors           String?
  warnings         String?
  importMapping    String?
  importOptions    String?
  validationPassed Boolean               @default(false)
  validationErrors String?
  previewData      String?
  importedBy       Int
  importedAt       DateTime              @default(now())
  completedAt      DateTime?
  importer         User                  @relation(fields: [importedBy], references: [id])
  timetable        ExamTimetable?        @relation(fields: [timetableId], references: [id])

  @@index([timetableId, status])
  @@index([importedBy, importedAt])
  @@map("timetable_imports")
}

model Venue {
  id                     Int                     @id @default(autoincrement())
  name                   String
  location               String
  capacity               Int
  institutionId          Int
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  timetableEntries       ExamTimetableEntry[]
  exams                  Exam[]
  rooms                  Room[]
  institution            Institution             @relation(fields: [institutionId], references: [id])
  // Logistics relations
  sessionLogs            ExamSessionLog[]
  invigilatorAssignments InvigilatorAssignment[]

  @@map("venues")
}

model Room {
  id                 Int                 @id @default(autoincrement())
  name               String
  capacity           Int
  venueId            Int
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  exams              Exam[]
  venue              Venue               @relation(fields: [venueId], references: [id])
  sessionLogs        ExamSessionLog[]
  examTimetableRooms ExamTimetableRoom[]

  @@unique([venueId, name])
  @@map("rooms")
}

model Script {
  id                 Int                @id @default(autoincrement())
  qrCode             String             @unique
  studentId          String
  examId             Int
  status             ScriptStatus       @default(GENERATED)
  notes              String?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  batchScriptId      Int?
  currentHolderId    Int?
  gradedById         Int?
  score              Float?
  maxScore           Float?
  gradedAt           DateTime?
  exam_registrations ExamRegistration[]
  incidents          Incident[]
  movements          ScriptMovement[]
  batchScript        BatchScript?       @relation(fields: [batchScriptId], references: [id])
  currentHolder      User?              @relation("ScriptsHolding", fields: [currentHolderId], references: [id])
  Exam               Exam               @relation(fields: [examId], references: [id])
  gradedBy           User?              @relation("ScriptsGraded", fields: [gradedById], references: [id])

  @@index([examId, status])
  @@index([batchScriptId])
  @@index([currentHolderId])
  @@index([status, currentHolderId])
  @@index([examId, status, updatedAt])
  @@index([studentId, examId])
  @@index([status, gradedAt])
  @@map("scripts")
}

model ScriptMovement {
  id            Int          @id @default(autoincrement())
  scriptId      Int
  type          MovementType
  fromUserId    Int?
  toUserId      Int?
  location      String?
  notes         String?
  timestamp     DateTime     @default(now())
  batchScriptId Int?
  batchScript   BatchScript? @relation(fields: [batchScriptId], references: [id])
  script        Script       @relation(fields: [scriptId], references: [id])
  toUser        User?        @relation("MovementTo", fields: [toUserId], references: [id])

  @@index([batchScriptId])
  @@index([scriptId, timestamp])
  @@index([type, timestamp])
  @@index([toUserId, timestamp])
  @@index([fromUserId, timestamp])
  @@map("script_movements")
}

model ExamRegistration {
  id                 Int                @id @default(autoincrement())
  studentId          Int
  examEntryId        Int
  studentQRCode      String             @unique
  isPresent          Boolean            @default(false)
  attendanceMarkedAt DateTime?
  attendanceMarkedBy Int?
  scriptSubmitted    Boolean            @default(false)
  scriptSubmittedAt  DateTime?
  seatNumber         String?
  specialArrangement String?
  notes              String?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  submittedTo        Int?               @map("submitted_to")
  batchScriptId      Int?               @map("batch_script_id")
  scriptId           Int?               @map("script_id")
  markedBy           User?              @relation("AttendanceMarkers", fields: [attendanceMarkedBy], references: [id])
  examEntry          ExamTimetableEntry @relation(fields: [examEntryId], references: [id])
  student            User               @relation("StudentExamRegistrations", fields: [studentId], references: [id])
  batchScript        BatchScript?       @relation(fields: [batchScriptId], references: [id], onUpdate: NoAction, map: "fk_exam_registrations_batch_script")
  script             Script?            @relation(fields: [scriptId], references: [id], onUpdate: NoAction, map: "fk_exam_registrations_script")
  submittedToUser    User?              @relation("ScriptSubmittedTo", fields: [submittedTo], references: [id], onUpdate: NoAction, map: "fk_exam_registrations_submitted_to")

  @@unique([studentId, examEntryId])
  @@index([examEntryId, scriptSubmitted])
  @@index([studentId])
  @@index([batchScriptId], map: "idx_exam_registrations_batch_script_id")
  @@index([examEntryId, isPresent])
  @@index([studentId, scriptSubmitted])
  @@index([attendanceMarkedBy, attendanceMarkedAt])
  @@map("exam_registrations")
}

model BatchScript {
  id                 Int                @id @default(autoincrement())
  examEntryId        Int
  courseId           Int
  batchQRCode        String             @unique
  status             BatchScriptStatus  @default(PENDING)
  totalRegistered    Int                @default(0)
  scriptsSubmitted   Int                @default(0)
  scriptsCollected   Int                @default(0)
  scriptsGraded      Int                @default(0)
  assignedLecturerId Int?
  sealedAt           DateTime?
  sealedBy           Int?
  deliveredAt        DateTime?
  completedAt        DateTime?
  notes              String?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  assignedLecturer   User?              @relation("BatchScriptsAssigned", fields: [assignedLecturerId], references: [id])
  course             Course             @relation(fields: [courseId], references: [id])
  examEntry          ExamTimetableEntry @relation(fields: [examEntryId], references: [id])
  sealedByUser       User?              @relation("BatchScriptsSealed", fields: [sealedBy], references: [id])
  exam_registrations ExamRegistration[]
  movements          ScriptMovement[]
  scripts            Script[]

  @@unique([examEntryId, courseId])
  @@index([courseId, status])
  @@index([assignedLecturerId])
  @@index([status, createdAt])
  @@index([examEntryId, status])
  @@index([assignedLecturerId, status])
  @@map("batch_scripts")
}

model Incident {
  id           Int              @id @default(autoincrement())
  type         IncidentType
  severity     IncidentSeverity @default(MEDIUM)
  status       IncidentStatus   @default(REPORTED)
  title        String
  description  String
  examId       Int?
  scriptId     Int?
  reportedById Int
  assignedToId Int?
  resolution   String?
  resolvedAt   DateTime?
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  assignedTo   User?            @relation("AssignedTo", fields: [assignedToId], references: [id])
  exam         Exam?            @relation(fields: [examId], references: [id])
  reportedBy   User             @relation("ReportedBy", fields: [reportedById], references: [id])
  script       Script?          @relation(fields: [scriptId], references: [id])

  @@index([examId, status])
  @@index([status, severity])
  @@index([reportedById, createdAt])
  @@index([assignedToId, status])
  @@index([type, status])
  @@map("incidents")
}

model ExamSessionLog {
  id          Int               @id @default(autoincrement())
  examEntryId Int
  action      ExamSessionAction
  performedBy Int
  performedAt DateTime          @default(now())

  // Action details
  details Json

  // Context
  venueId       Int?
  roomId        Int?
  studentId     Int?
  invigilatorId Int?

  // Audit
  ipAddress String?
  userAgent String?
  notes     String?

  createdAt DateTime @default(now())

  // Relations
  examEntry   ExamTimetableEntry @relation(fields: [examEntryId], references: [id], onDelete: Cascade)
  performer   User               @relation(fields: [performedBy], references: [id])
  venue       Venue?             @relation(fields: [venueId], references: [id])
  room        Room?              @relation(fields: [roomId], references: [id])
  student     User?              @relation("SessionLogStudent", fields: [studentId], references: [id])
  invigilator User?              @relation("SessionLogInvigilator", fields: [invigilatorId], references: [id])

  @@index([examEntryId, performedAt])
  @@index([performedBy, performedAt])
  @@index([venueId, performedAt])
  @@index([action, performedAt])
  @@index([studentId, examEntryId])
  @@index([invigilatorId, examEntryId])
  @@map("exam_session_logs")
}

model InvigilatorAssignment {
  id            Int             @id @default(autoincrement())
  examEntryId   Int
  invigilatorId Int
  role          InvigilatorRole
  assignedBy    Int
  assignedAt    DateTime        @default(now())

  // Status tracking
  status       AssignmentStatus @default(ASSIGNED)
  checkedInAt  DateTime?
  checkedOutAt DateTime?

  // Assignment details
  venueId Int
  duties  String?

  // Reassignment tracking
  reassignedFrom     Int?
  reassignedAt       DateTime?
  reassignmentReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  examEntry          ExamTimetableEntry      @relation(fields: [examEntryId], references: [id], onDelete: Cascade)
  invigilator        User                    @relation(fields: [invigilatorId], references: [id])
  assignedByUser     User                    @relation("AssignmentAssignedBy", fields: [assignedBy], references: [id])
  venue              Venue                   @relation(fields: [venueId], references: [id])
  previousAssignment InvigilatorAssignment?  @relation("ReassignmentChain", fields: [reassignedFrom], references: [id])
  reassignments      InvigilatorAssignment[] @relation("ReassignmentChain")

  @@unique([examEntryId, invigilatorId]) // Prevent duplicate assignments
  @@index([examEntryId, status])
  @@index([invigilatorId, assignedAt])
  @@index([venueId, assignedAt])
  @@index([status, assignedAt])
  @@index([invigilatorId, status])
  @@map("invigilator_assignments")
}

model StudentVerification {
  id          Int      @id @default(autoincrement())
  examEntryId Int
  studentId   Int
  verifiedBy  Int
  verifiedAt  DateTime @default(now())

  // Verification details
  status             VerificationStatus @default(PENDING)
  method             VerificationMethod
  seatNumber         String?
  specialArrangement String?

  // Biometric/QR verification
  qrCode          String?
  biometricMatch  Boolean?
  confidenceScore Float?

  // Issues encountered
  issues String? // JSON array of VerificationIssue
  notes  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  examEntry ExamTimetableEntry @relation(fields: [examEntryId], references: [id], onDelete: Cascade)
  student   User               @relation(fields: [studentId], references: [id])
  verifier  User               @relation("VerificationVerifier", fields: [verifiedBy], references: [id])

  @@unique([examEntryId, studentId]) // One verification per student per exam
  @@index([examEntryId, verifiedAt])
  @@index([studentId, examEntryId])
  @@index([verifiedBy, verifiedAt])
  @@index([status, method])
  @@index([examEntryId, status])
  @@map("student_verifications")
}

model ExamIncident {
  id          Int              @id @default(autoincrement())
  examEntryId Int
  type        ExamIncidentType
  severity    IncidentSeverity @default(MEDIUM)
  status      IncidentStatus   @default(REPORTED)

  // Incident details
  title       String
  description String
  location    String?

  // Reporting
  reportedBy Int
  reportedAt DateTime @default(now())
  assignedTo Int?

  // Resolution
  resolution String?
  resolvedBy Int?
  resolvedAt DateTime?

  // Evidence
  attachments String? // JSON array of file URLs

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  examEntry          ExamTimetableEntry       @relation(fields: [examEntryId], references: [id], onDelete: Cascade)
  reporter           User                     @relation("IncidentReporter", fields: [reportedBy], references: [id])
  assignee           User?                    @relation("IncidentAssignee", fields: [assignedTo], references: [id])
  resolver           User?                    @relation("IncidentResolver", fields: [resolvedBy], references: [id])
  affectedStudents   ExamIncidentStudent[]
  affectedInvigilators ExamIncidentInvigilator[]
  witnesses          ExamIncidentWitness[]

  @@index([examEntryId, status])
  @@index([reportedBy, reportedAt])
  @@index([assignedTo, status])
  @@index([type, severity, status])
  @@index([status, reportedAt])
  @@map("exam_incidents")
}

// Junction tables for ExamIncident relationships
model ExamIncidentStudent {
  id         Int          @id @default(autoincrement())
  incidentId Int
  studentId  Int
  notes      String?
  createdAt  DateTime     @default(now())

  incident ExamIncident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  student  User         @relation("IncidentAffectedStudents", fields: [studentId], references: [id])

  @@unique([incidentId, studentId])
  @@index([incidentId])
  @@index([studentId])
  @@map("exam_incident_students")
}

model ExamIncidentInvigilator {
  id            Int          @id @default(autoincrement())
  incidentId    Int
  invigilatorId Int
  notes         String?
  createdAt     DateTime     @default(now())

  incident    ExamIncident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  invigilator User         @relation("IncidentAffectedInvigilators", fields: [invigilatorId], references: [id])

  @@unique([incidentId, invigilatorId])
  @@index([incidentId])
  @@index([invigilatorId])
  @@map("exam_incident_invigilators")
}

model ExamIncidentWitness {
  id         Int          @id @default(autoincrement())
  incidentId Int
  witnessId  Int
  statement  String?
  createdAt  DateTime     @default(now())

  incident ExamIncident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  witness  User         @relation("IncidentWitnesses", fields: [witnessId], references: [id])

  @@unique([incidentId, witnessId])
  @@index([incidentId])
  @@index([witnessId])
  @@map("exam_incident_witnesses")
}

// Exam Logistics Aggregate Model - Central logistics data for each exam entry
model ExamLogistics {
  id          Int      @id @default(autoincrement())
  examEntryId Int      @unique

  // Student metrics
  totalExpected      Int      @default(0)
  totalPresent       Int      @default(0)
  totalAbsent        Int      @default(0)
  totalLateArrivals  Int      @default(0)

  // Script tracking metrics
  scriptsSubmitted   Int      @default(0)
  scriptsCollected   Int      @default(0)
  scriptsPending     Int      @default(0)

  // Invigilator metrics
  invigilatorsAssigned Int    @default(0)
  invigilatorsPresent  Int    @default(0)
  invigilatorsAbsent   Int    @default(0)

  // Status flags
  sessionStatus       ExamSessionStatusType @default(NOT_STARTED)
  dataVerificationStatus VerificationStatus @default(PENDING)
  hasIncidents        Boolean  @default(false)
  hasUnresolvedIncidents Boolean @default(false)
  capacityExceeded    Boolean  @default(false)

  // Tracking timestamps
  sessionStartedAt    DateTime?
  sessionEndedAt      DateTime?
  lastVerificationAt  DateTime?
  lastIncidentAt      DateTime?

  // Metadata
  notes               String?
  metadata            Json?    // For additional flexible data

  // Audit
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  lastSyncedAt        DateTime @default(now())

  // Relations
  examEntry ExamTimetableEntry @relation(fields: [examEntryId], references: [id], onDelete: Cascade)

  @@index([examEntryId])
  @@index([sessionStatus, examEntryId])
  @@index([hasUnresolvedIncidents, examEntryId])
  @@index([dataVerificationStatus, examEntryId])
  @@map("exam_logistics")
}

enum UserRole {
  SUPER_ADMIN
  ADMIN
  FACULTY_ADMIN
  DEAN
  HOD
  EXAMS_OFFICER
  SCRIPT_HANDLER
  INVIGILATOR
  LECTURER
  STUDENT
}

enum AcademicRankLevel {
  GRADUATE_ASSISTANT
  ASSISTANT_LECTURER
  LECTURER
  SENIOR_LECTURER
  PRINCIPAL_LECTURER
  ASSOCIATE_PROFESSOR
  PROFESSOR
}

enum ProgramType {
  CERTIFICATE
  DIPLOMA
  HND
  BACHELOR
  MASTERS
  PHD
}

enum ProgramLevel {
  UNDERGRADUATE
  POSTGRADUATE
}

enum EnrollmentStatus {
  ACTIVE
  DEFERRED
  GRADUATED
  WITHDRAWN
  SUSPENDED
}

enum AcademicStatus {
  GOOD_STANDING
  PROBATION
  SUSPENDED
}

enum CourseType {
  CORE
  ELECTIVE
  GENERAL
}

enum EmploymentType {
  FULL_TIME
  PART_TIME
  CONTRACT
  VISITING
}

enum EmploymentStatus {
  ACTIVE
  ON_LEAVE
  RETIRED
  TERMINATED
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING_VERIFICATION
}

enum CalendarImportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  PARTIALLY_COMPLETED
}

enum CalendarFileType {
  CSV
  EXCEL
  ICAL
  JSON
}

enum RegistrationStatus {
  ACTIVE
  COMPLETED
  CANCELLED
}

enum RegistrationItemStatus {
  REGISTERED
  DROPPED
  COMPLETED
}

enum AcademicStanding {
  GOOD_STANDING
  PROBATION
  ACADEMIC_WARNING
  SUSPENDED
  DISMISSED
}

enum ExamStatus {
  PLANNED
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  POSTPONED
}

enum ExamTimetableStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  PUBLISHED
  IN_PROGRESS
  COMPLETED
  ARCHIVED
}

enum TimetableApprovalStatus {
  NOT_SUBMITTED
  PENDING
  APPROVED
  REJECTED
  REVISION_REQUIRED
}

enum ExamTimetableEntryStatus {
  DRAFT
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  RESCHEDULED
}

enum TimetableFileType {
  CSV
  EXCEL
  ICAL
  JSON
  PDF
}

enum TimetableImportStatus {
  PENDING
  VALIDATING
  VALIDATED
  IMPORTING
  COMPLETED
  FAILED
  PARTIALLY_COMPLETED
}

enum ConflictType {
  STUDENT_OVERLAP
  VENUE_OVERLAP
  INVIGILATOR_OVERLAP
  CAPACITY_EXCEEDED
  TIME_VIOLATION
  DATE_VIOLATION
  PREREQUISITE_VIOLATION
}

enum ConflictSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ScriptStatus {
  GENERATED
  DISTRIBUTED
  COLLECTED
  VERIFIED
  SCANNED
  DISPATCHED
  RECEIVED_FOR_GRADING
  GRADING_IN_PROGRESS
  GRADED
  RETURNED
}

enum MovementType {
  GENERATED
  DISTRIBUTED_TO_VENUE
  COLLECTED_FROM_STUDENT
  VERIFIED_BY_INVIGILATOR
  SCANNED_BY_HANDLER
  DISPATCHED_TO_GRADER
  RECEIVED_BY_GRADER
  GRADED
  RETURNED_TO_REGISTRY
  BATCH_SEALED
  BATCH_TRANSFERRED
}

enum IncidentType {
  ACADEMIC_MISCONDUCT
  TECHNICAL_ISSUE
  MEDICAL_EMERGENCY
  MISSING_SCRIPT
  DAMAGED_SCRIPT
  LATE_ARRIVAL
  IDENTITY_VERIFICATION
  VENUE_ISSUE
  OTHER
}

enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum IncidentStatus {
  REPORTED
  UNDER_INVESTIGATION
  RESOLVED
  CLOSED
  ESCALATED
}

enum ActionType {
  CREATE
  READ
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  EXPORT
  IMPORT
}

enum BatchScriptStatus {
  PENDING
  IN_COLLECTION
  SEALED
  IN_TRANSIT
  WITH_LECTURER
  GRADING_IN_PROGRESS
  GRADING_COMPLETED
  RETURNED_TO_REGISTRY
  ARCHIVED
}

enum StudentIdFormat {
  SEQUENTIAL // e.g., 0721000001
  ACADEMIC_YEAR // e.g., BT/ITS/24/001
  CUSTOM // Custom pattern defined by institution
}

enum StudentIdYearPosition {
  PREFIX // Year at the beginning
  MIDDLE // Year in the middle
  SUFFIX // Year at the end
}

// ========================================
// EXAM LOGISTICS ENUMS
// ========================================

enum ExamSessionAction {
  STUDENT_CHECK_IN
  STUDENT_CHECK_OUT
  INVIGILATOR_CHECK_IN
  INVIGILATOR_CHECK_OUT
  ROOM_CHANGE
  INVIGILATOR_REASSIGNMENT
  INCIDENT_REPORTED
  INCIDENT_RESOLVED
  SESSION_STARTED
  SESSION_ENDED
  VERIFICATION_OVERRIDE
  EMERGENCY_ACTION
}

enum InvigilatorRole {
  CHIEF_INVIGILATOR
  INVIGILATOR
  RELIEF_INVIGILATOR
}

enum AssignmentStatus {
  ASSIGNED
  CONFIRMED
  CHECKED_IN
  ACTIVE
  CHECKED_OUT
  COMPLETED
  CANCELLED
  REASSIGNED
}

enum VerificationStatus {
  PENDING
  VERIFIED
  FAILED
  OVERRIDDEN
  ABSENT
}

enum VerificationMethod {
  QR_CODE
  BIOMETRIC
  MANUAL
  PHOTO_ID
}

enum VerificationIssue {
  INVALID_QR
  BIOMETRIC_MISMATCH
  WRONG_VENUE
  WRONG_TIME
  NO_REGISTRATION
  LATE_ARRIVAL
}

enum ExamIncidentType {
  STUDENT_ABSENCE
  INVIGILATOR_ABSENCE
  TECHNICAL_ISSUE
  SECURITY_BREACH
  MEDICAL_EMERGENCY
  VENUE_ISSUE
  ACADEMIC_MISCONDUCT
  MATERIAL_MISSING
  OTHER
}

enum ExamSessionStatusType {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  POSTPONED
}

enum RoomStatusType {
  AVAILABLE
  OCCUPIED
  MAINTENANCE
  CLOSED
}

enum PresenceStatus {
  EXPECTED
  PRESENT
  LATE
  ABSENT
  RELIEVED
}
